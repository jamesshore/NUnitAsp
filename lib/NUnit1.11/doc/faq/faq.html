<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
<title>NUnit FAQ</title>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.5 [en] (Win98; I) [Netscape]">
   <meta name="Author" content="Philip Craig">
</head>
<body>

<h1>
<font color="#33ff33">N</font><font color="#cc0000">U</font>nit Frequently
Asked Questions</h1>

<hr WIDTH="100%">
<li>
<a href="#How do I implement a test case for thrown">How do I implement a test case for a thrown exception?</a>

<li>
<a href="#How do I organize my Test">How do I organize my test cases?</a>

<li>
<a href="#How do I run setup code only once">How do I run setup code once
for all my TestCases?</a>

<li>
<a href="#I want to debug when a test">I want to debug when a test fails</a>

<br>
<hr><a NAME="How do I implement a test case for thrown"></a>
<h2>
How do I implement a test case for a thrown exception?</h2>
Catch the exception and if it isn't thrown call the <b>Fail</b> method.
Fail signals the failure of a test case. Here is an example:
<blockquote><tt>public void TestArgumentOutOfRangeException() {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ArrayList l =          new ArrayList(10)</tt>
<br><tt>&nbsp;&nbsp;&nbsp; try {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object 
  o=  
    
     l[l.Count];</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fail("Should raise
an ArgumentOutOfRangeException");</tt>
<br><tt>&nbsp;&nbsp;&nbsp; } catch (ArgumentOutOfRangeException) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt></blockquote>
or use the ExceptionTestCase as follows.
<br>1) make your TestCase class a subclass of ExceptionTestCase.
<br>2) write the test ignoring exceptions
<blockquote><tt>public void TestArgumentOutOfRangeException() {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ArrayList l=       new ArrayList(10);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; l[l.Count];</tt>
<br><tt>}</tt></blockquote>
3) create the TestCase:
<br><tt>&nbsp;&nbsp;&nbsp; Test t=       new ExceptionTestCase("TestArgumentOutOfRangeException",
typeof(ArgumentOutOfRangeException))</tt>
<p>Looking at this again, the first way is simpler. Sigh...
<h2>
<a NAME="How do I organize my Test"></a>How do I organize my Test Cases?</h2>
Here is one way:
<ol>
<li>
create a test namespace for each of your application namespaces. For example,
for a namespace <b>MyApp.Util </b>define <b>MyApp.UtilTest</b>. Put all the fixtures 
  for the Util namespace into this namespace. 
  

<li>
in MyApp.UtilTest define a class which creates a suite with all the tests
in this namespace. To do so define a class <b>AllTests</b> which includes a single static Suite 
  property. Here is an example: 

<br><tt>&nbsp;public static ITest Suite {</tt>
<br><tt>&nbsp;&nbsp;  get {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; 
  TestSuite suite= 
    
         new TestSuite();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;    suite.AddTest(Fixture1.Suite);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;    suite.AddTest(Fixture2.Suite);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;    return suite;</tt>
<br><tt>&nbsp;&nbsp;  }</tt>
<br><tt>&nbsp;}</tt>
<li>
define similar AllTests classes that create higher level suites containing
the suites from other test packages.</li>
</ol>When the 
fixtures are in a separate test assembly the test cases don't have access to the 
methods and fields with internal visibility. A variation of the above convention 
is to put all fixtures into the application assembly itself. This gives the 
fixtures access to all the assembly visible methods and fields. To separate the 
fixture classes from the production classes put them into a separate directory 
that you then add to the project. This makes it easy to ship the production 
classes independent of the fixtures. 
<ol></ol>
<a NAME="How do I run setup code only once"></a>
<h2>
How do I run setup code once for all my TestCases?</h2>
Wrap the top level suite in a subclass of TestSetup. Here is a sample AllTests.Suite
method:
<blockquote><tt>protected class WrappedTestSetup: TestSetup {</tt>
<br><tt>&nbsp; public WrappedTestSetup(ITest test) : base(test) {}</tt>&nbsp;
<br><tt>&nbsp; protected override void SetUp() {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; OneTimeSetUp();</tt>
<br><tt>&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; };</tt>
<br>
<br><tt>public static ITest Suite {</tt>
<br><tt>&nbsp; get {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; TestSuite suite=       new TestSuite();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ...add your tests and suites here...</tt>
<br><tt>&nbsp;&nbsp;&nbsp; TestSetup wrapper=        new WrappedTestSetup(suite);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return wrapper;</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt></blockquote>
<h2>
<a NAME="I want to debug when a test"></a>I want to debug when a test fails</h2>
Start the test 
runner under the debugger and configure the debugger so that it catches the 
NUnit.Framework.AssertionFailedError. How you do this depends on the used IDE. 
Most debuggers support to stop the program when a specific exception is fired. 
Notice, that this will only break into the debugger when an "anticipated" 
assertion failed error occurs.
<br>
<h2>Where are the test runner properties documented?</h2>
See the <a href="doc/NUnitPreferences.html">NUnit preferences</a> documentation.
<hr WIDTH="100%">

</body>
</html>
